<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>File Uploader</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .flex {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      button {
        padding: 10px;
        font-size: 16px;
        cursor: pointer;
      }
      .error {
        color: red;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
      }
    </style>
    <style>
      /* ... (keep the existing styles) ... */
      .progress-bar {
        width: 100%;
        background-color: #f0f0f0;
        margin-bottom: 5px;
      }
      .progress-bar-fill {
        height: 20px;
        background-color: #4caf50;
        width: 0%;
        transition: width 0.3s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div class="flex">
      <h1>File Uploader</h1>
      <input type="file" id="fileInput" multiple />
      <button id="uploadButton">Upload</button>
      <div id="progressContainer"></div>
      <div id="errorDiv" class="error"></div>
      <h2>Uploaded Files</h2>
      <table id="filesTable">
        <thead>
          <tr>
            <th>File Name</th>
            <th>Size</th>
            <th>Type</th>
            <th>Uploaded At</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <script>
      const CHUNK_SIZE = 1024 * 1024; // 1MB chunks
      const MAX_PARALLEL_UPLOADS = 3; // Number of parallel uploads

      let files = [];
      let uploading = false;
      let error = null;

      const fileInput = document.getElementById("fileInput");
      const uploadButton = document.getElementById("uploadButton");
      const progressContainer = document.getElementById("progressContainer");
      const errorDiv = document.getElementById("errorDiv");
      const filesTable = document
        .getElementById("filesTable")
        .getElementsByTagName("tbody")[0];

      fileInput.addEventListener("change", handleFileChange);
      uploadButton.addEventListener("click", handleUpload);

      function handleFileChange(e) {
        files = Array.from(e.target.files);
        progressContainer.innerHTML = "";
        setError(null);
      }

      async function uploadChunk(file, chunk, chunkMetadata, totalChunks) {
        const formData = new FormData();
        formData.append("chunk", chunk, file.name);
        formData.append("fileId", file.fileId);
        formData.append("chunkMetadata", JSON.stringify(chunkMetadata));
        formData.append("totalChunks", totalChunks.toString());
        formData.append("fileSize", file.size.toString());
        formData.append("fileType", file.type);

        try {
          await axios.post("/upload", formData, {
            headers: { "Content-Type": "multipart/form-data" },
          });
        } catch (error) {
          console.error("Error uploading chunk:", error);
          throw error;
        }
      }

      async function uploadFile(file, progressBar) {
        file.fileId = uuid.v4();
        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

        for (let i = 0; i < totalChunks; i++) {
          const start = i * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, file.size);
          const chunk = file.slice(start, end);
          const chunkMetadata = { chunkIndex: i, start, end };

          try {
            await uploadChunk(file, chunk, chunkMetadata, totalChunks);
            updateProgress(progressBar, ((i + 1) / totalChunks) * 100);
          } catch (error) {
            console.error(`Error uploading chunk ${i} of ${file.name}:`, error);
            i--; // Retry this chunk
          }
        }
      }

      async function handleUpload() {
        if (files.length === 0 || uploading) return;
        setUploading(true);
        setError(null);

        const progressBars = files.map(createProgressBar);

        try {
          for (let i = 0; i < files.length; i += MAX_PARALLEL_UPLOADS) {
            const batch = files.slice(i, i + MAX_PARALLEL_UPLOADS);
            await Promise.all(
              batch.map((file, index) =>
                uploadFile(file, progressBars[i + index])
              )
            );
          }
          console.log("All files uploaded successfully");
          fetchFiles();
        } catch (error) {
          console.error("Error during upload:", error);
          setError("An error occurred during upload. Please try again.");
        } finally {
          setUploading(false);
        }
      }

      function createProgressBar(file) {
        const progressBarContainer = document.createElement("div");
        progressBarContainer.className = "progress-bar";
        const progressBarFill = document.createElement("div");
        progressBarFill.className = "progress-bar-fill";
        const progressText = document.createElement("div");
        progressText.textContent = `${file.name}: 0%`;

        progressBarContainer.appendChild(progressBarFill);
        progressBarContainer.appendChild(progressText);
        progressContainer.appendChild(progressBarContainer);

        return { fill: progressBarFill, text: progressText };
      }

      function updateProgress(progressBar, value) {
        progressBar.fill.style.width = `${value}%`;
        progressBar.text.textContent = `${
          progressBar.text.textContent.split(":")[0]
        }: ${value.toFixed(2)}%`;
      }

      function setError(value) {
        error = value;
        errorDiv.textContent = error || "";
      }

      function setUploading(value) {
        uploading = value;
        uploadButton.disabled = files.length === 0 || uploading;
        uploadButton.textContent = uploading ? "Uploading..." : "Upload";
        fileInput.disabled = uploading;
      }
      async function fetchFiles() {
        try {
          const response = await axios.get("/files");
          const files = response.data;
          updateFilesTable(files);
        } catch (error) {
          console.error("Error fetching files:", error);
          setError("Error fetching files. Please try again.");
        }
      }

      function updateFilesTable(files) {
        filesTable.innerHTML = "";
        files.forEach((file) => {
          const row = filesTable.insertRow();
          row.insertCell(0).textContent = file.originalname;
          row.insertCell(1).textContent = formatFileSize(file.fileSize);
          row.insertCell(2).textContent = file.fileType;
          row.insertCell(3).textContent = new Date(
            file.uploadedAt
          ).toLocaleString();
          const actionCell = row.insertCell(4);
          const downloadLink = document.createElement("a");
          downloadLink.href = `/${file.id}_${file.originalname}`;
          downloadLink.textContent = "Download";
          downloadLink.download = file.originalname;
          actionCell.appendChild(downloadLink);
        });
      }

      function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + " B";
        if (bytes < 1048576) return (bytes / 1024).toFixed(2) + " KB";
        if (bytes < 1073741824) return (bytes / 1048576).toFixed(2) + " MB";
        return (bytes / 1073741824).toFixed(2) + " GB";
      }

      // Fetch files on page load
      fetchFiles();
    </script>
  </body>
</html>
